---
layout: post
title: Теория тестирования от А до Я.
permalink: /testing-theory
date: 2021-08-24
description: |
    
author: Ilarion Halushka
keywords:
    - 
tags: 
---

**`После прочтения + понимания + изучения + конспектирования + заучивания этой статьи курсы тестировщиков уже не нужны.`** 

## 1. Определения

**Тестирование ПО** — проверка соответствия между реальным и ожидаемым поведением программы.

**Тестирование**  — это одна из техник контроля качества, включающая в себя активности по:
* Test Management (планированию работ) 
* Test Design (проектирование тестов) 
* Test Execution (выполнение тестов)
* Test Analysis (анализ результатов тестирования)

**Качество ПО (Software Quality)** 
— это совокупность характеристик программного обеспечения, 
относящихся к его способности удовлетворять установленные и предполагаемые потребности.

## 2. Валидация vs Верификация

**Верификация (verification)** — оценка соответствия продукта требованиям (спецификации).

Отвечает на вопрос: "Система работает в соответствии с требованиями?"

**Валидация (validation)** — оценка соответствия продукта ожиданиям и требованиям пользователей.

Отвечает на вопрос: "Требования удовлетворяют ожидания пользователя?"

## 3. Цели тестирования
1. Повысить вероятность того, что приложение:
* будет соответствовать всем описанным требованиям.
* будет работать правильно при любых обстоятельствах.

2. Предоставление актуальной информации о состоянии продукта на данный момент.

## 4. Этапы тестирования
1. Анализ продукта
1. Работа с требованиями
1. Разработка тест плана
1. Создание тестовой документации
1. Тестирование
1. Отчет о тестировании
1. Стабилизация
1. Эксплуатация

## 5. Тест план <a target="_blank" rel="noreferrer" href="https://www.youtube.com/channel/UC-nnrcFlfveeW8iBRJe_XXQ" title="Youtube"><i class="fa fa-1x fa-youtube-square"></i></a>

**Test Plan** — это документ, описывающий весь объем работ по тестированию

Отвечает на вопросы:

* Что?
* Когда?
* Критерии начала/окончания тестирования.
* Окружение (environment) dev/staging/production?
* Подходы/техники/инструменты/виды тестирования?
* Браузеры/версии/OS/разрешения экрана?
* Кто? Обязанности? Ресурсы? Обучение?
* Сроки? 
* График?
* Стратегия тестирования.
* Ссылки на документацию.
* Ссылки на требования.


## 6. Тест дизайн <a target="_blank" rel="noreferrer" href="https://www.youtube.com/channel/UC-nnrcFlfveeW8iBRJe_XXQ" title="Youtube"><i class="fa fa-1x fa-youtube-square"></i></a>

**Test design** — это этап процесса тестирования ПО, на котором проектируются и создаются тест кейсы, в соответствии с критериями качества и целями тестирования.

* **Тест аналитик** — определяет «ЧТО тестировать?»
* **Тест дизайнер** — определяет «КАК тестировать?»
* **Реальность** - все делает 1 человек :)


## 7. Техники тест дизайна <a target="_blank" rel="noreferrer" href="https://www.youtube.com/channel/UC-nnrcFlfveeW8iBRJe_XXQ" title="Youtube"><i class="fa fa-1x fa-youtube-square"></i></a>

1. **Исчерпывающее тестирование (Exhaustive Testing)** <a target="_blank" rel="noreferrer" href="https://www.youtube.com/channel/UC-nnrcFlfveeW8iBRJe_XXQ" title="Youtube"><i class="fa fa-1x fa-youtube-square"></i></a>
  - проверка всех возможных комбинаций входных значений. 
  На практике применение этого метода не представляется возможным. (см. принцип тестирования №2)

1. **Эквивалентное Разделение (Equivalence Partitioning)** <a target="_blank" rel="noreferrer" href="https://www.youtube.com/channel/UC-nnrcFlfveeW8iBRJe_XXQ" title="Youtube"><i class="fa fa-1x fa-youtube-square"></i></a>
   - Как пример, у вас есть диапазон допустимых значений от 1.00 до 10.00 долларов, 
   вы должны выбрать одно любое верное значение внутри интервала, скажем, 
   5.00, и любые неверные значения вне интервала, например 0.99 и 11.00.

1. **Анализ Граничных Значений (Boundary Value Analysis)** <a target="_blank" rel="noreferrer" href="https://www.youtube.com/channel/UC-nnrcFlfveeW8iBRJe_XXQ" title="Youtube"><i class="fa fa-1x fa-youtube-square"></i></a>
- Как пример, у вас есть диапазон допустимых значений от 1.00 до 10.00 долларов.
- **Two value (двузначный) BVA**: валидные граничные значения 1.00, 10.00, и невалидные значения 0.99 и 10.01. 
- **Three/Full value (трехзначный) BVA**: валидные граничные значения 1.00, 1.01, 10.00, 9.99, и невалидные значения 0.99 и 10.01.

1. **Причина / Следствие (Cause/Effect)** <a target="_blank" rel="noreferrer" href="https://www.youtube.com/channel/UC-nnrcFlfveeW8iBRJe_XXQ" title="Youtube"><i class="fa fa-1x fa-youtube-square"></i></a>
- ввод комбинаций условий (причин), для получения ответа от системы (следствие). 
- Например, вы проверяете возможность добавлять клиента:
- **Причина**: необходимо заполнить поля «Имя», «Адрес», «Номер Телефона» и нажать кнопку «Добавить».
- **Следствие**: После нажатия на кнопку «Добавить», система добавляет клиента в базу данных и показывает его номер на экране.

1. **Предугадывание ошибки (Error Guessing)** <a target="_blank" rel="noreferrer" href="https://www.youtube.com/channel/UC-nnrcFlfveeW8iBRJe_XXQ" title="Youtube"><i class="fa fa-1x fa-youtube-square"></i></a>
- использование знаний системы и способность к 
   интерпретации спецификации на предмет того, чтобы «предугадать» 
   при каких входных условиях система может выдать ошибку.
- Например, спецификация говорит: «пользователь должен ввести код».
- Тестировщик будет думать: «Что, если я не введу код?», «Что, если я введу неправильный код?»...


## 8. Продвинутые техники тест дизайна

`Удиви интервьюера`

1. **Попарное тестирование (Pairwise Testing)** <a target="_blank" rel="noreferrer" href="https://www.youtube.com/channel/UC-nnrcFlfveeW8iBRJe_XXQ" title="Youtube"><i class="fa fa-1x fa-youtube-square"></i></a>
- Формирование таких наборов тестовых данных, в которых каждое тестируемое значение каждого из
  проверяемых параметров хотя бы единожды сочетается с каждым тестируемым значением всех остальных проверяемых параметров.
- Суть техники — мы не проверяем все сочетания всех значений, но проверяем все пары значений.

2. **Таблица принятия решений (Decision table)** <a target="_blank" rel="noreferrer" href="https://www.youtube.com/channel/UC-nnrcFlfveeW8iBRJe_XXQ" title="Youtube"><i class="fa fa-1x fa-youtube-square"></i></a>
- В таблицах решений представлен набор условий, одновременное выполнение которых должно привести к определенному действию/решению.

3. **Диаграмма (граф) состояний-переходов (State Transition diagram)** <a target="_blank" rel="noreferrer" href="https://www.youtube.com/channel/UC-nnrcFlfveeW8iBRJe_XXQ" title="Youtube"><i class="fa fa-1x fa-youtube-square"></i></a>
- диаграмма для описания поведения системы. 
- Система имеет конечное число состояний и переходов между ними.
- Диаграмма может быть переведена в Таблицу состояний-переходов (или в таблицу принятия решений).

4. **Use case (пользовательские сценарии)** <a target="_blank" rel="noreferrer" href="https://www.youtube.com/channel/UC-nnrcFlfveeW8iBRJe_XXQ" title="Youtube"><i class="fa fa-1x fa-youtube-square"></i></a>

&nbsp;&nbsp;&nbsp; Это сценарий взаимодействия пользователя с системой для достижения цели.

Use case содержит:
* кто использует систему (например роль админ/покупатель/продавец).
* что пользователь хочет сделать.
* цели пользователя.
* шаги, которые выполняет пользователь.
* описание того, как система реагируют на действия пользователя.


## 9. Бонусные и авторские техники тест дизайна

`Просвети интервьюера. Открой ему глаза.`

1 - **Блок-схема (block scheme/diagram)** <a target="_blank" rel="noreferrer" href="https://www.youtube.com/channel/UC-nnrcFlfveeW8iBRJe_XXQ" title="Youtube"><i class="fa fa-1x fa-youtube-square"></i></a>

&nbsp;&nbsp;&nbsp; Блок-схему можно использовать как технику тест дизайна, составляя тест-кейсы по логике схемы.


2 - **Шляпы / роли** <a target="_blank" rel="noreferrer" href="https://www.youtube.com/channel/UC-nnrcFlfveeW8iBRJe_XXQ" title="Youtube"><i class="fa fa-1x fa-youtube-square"></i></a>

&nbsp;&nbsp;&nbsp; Техника "Шляпы / роли" чем-то схожа с техникой составления тест кейсов по Use Case.

&nbsp;&nbsp;&nbsp; Надеваем шляпу определенной роли пользователя и представляем себя в его роли.
   
&nbsp;&nbsp;&nbsp; Пример: надеваем шляпу Кастинг Директора и размышляем как новый функционал будет работать для этой роли. 
Представляем, какие могут быть зависимости и особенности системы для Кастинг Директора.
Размышляем, какие бизнес цели преследует Кастинг директор в нашей системе.


3 - **Разговорчики-driven (talks-driven)** <a target="_blank" rel="noreferrer" href="https://www.youtube.com/channel/UC-nnrcFlfveeW8iBRJe_XXQ" title="Youtube"><i class="fa fa-1x fa-youtube-square"></i></a>

&nbsp;&nbsp;&nbsp; О "Разговорчики-driven", "Analytics-driven", "Bug-driven" я пока нигде не слышал.

`Каждый имеет право придумать свою технику тест дизайна.` © Илларион

&nbsp;&nbsp;&nbsp; **Разговорчики-driven (talks-driven)** - собираем в одной комнате/звонке одного или нескольких
программистов, менеджеров, клиентов, тестировщиков и тд. И начинаем допрос о конкретной функции или всей системе.

&nbsp;&nbsp;&nbsp; Если фантазия не работает, то задаем Wh-вопросы:

what, when, where, who, whom, which, whose, why and how -
что, когда, где, кто, кому, какой, чей, почему, как

Для продвинутых: сначала собираем всех по одному, а потом по несколько человек. 
Не выпускаем, пока не получим все ответы и не решим какие тесты проектировать.


4 - **Аналитика-driven (analytics-driven)** <a target="_blank" rel="noreferrer" href="https://www.youtube.com/channel/UC-nnrcFlfveeW8iBRJe_XXQ" title="Youtube"><i class="fa fa-1x fa-youtube-square"></i></a>

&nbsp;&nbsp;&nbsp; Если на проекте используется аналитика, например при кликах на кнопки
или при открытии страниц отправляются ивенты (events) в систему для аналитики, то можно
использовать данные аналитики для составления тест кейсов.

&nbsp;&nbsp;&nbsp; Мы знаем куда пользователи чаще всего кликают, на каких страницах проводят больше всего времени.
Почему бы основываясь на этих данных не составить тест кейсы?


5 - **Баг-driven (bugs-driven)** <a target="_blank" rel="noreferrer" href="https://www.youtube.com/channel/UC-nnrcFlfveeW8iBRJe_XXQ" title="Youtube"><i class="fa fa-1x fa-youtube-square"></i></a>

&nbsp;&nbsp;&nbsp; Принцип тестирования №4 Скопление дефектов (Defects clustering) гласит, что "бОльшая часть дефектов .... содержится в небольшом количестве модулей".

&nbsp;&nbsp;&nbsp; Основываясь на найденных ранее багах и на обращениях клиентов в службу поддержки,
можно определить "больные" места системы и сконцентрировать тест кейсы на этих модулях системы.

&nbsp;&nbsp;&nbsp; Дополнительно над найденными багами можно посидеть и подумать
"а может ли аналогичный баг быть в другой части системы?".


## 10. Exploratory vs Ad-hoc testing

**Исследовательское тестирование (exploratory testing)** <a target="_blank" rel="noreferrer" href="https://www.youtube.com/channel/UC-nnrcFlfveeW8iBRJe_XXQ" title="Youtube"><i class="fa fa-1x fa-youtube-square"></i></a>
- это одновременное изучение системы, проектирование тестов (тест дизайн) и тестирование.
- Данная техника базируется на опыте тестировщика (experience based).
- Пример: приходит тестировщик на новый проект и начинает одновременно изучать сайт,
  писать чек-лист и проходить этот чек-лист (тестировать).

**Ad-hoc тестирование** <a target="_blank" rel="noreferrer" href="https://www.youtube.com/channel/UC-nnrcFlfveeW8iBRJe_XXQ" title="Youtube"><i class="fa fa-1x fa-youtube-square"></i></a>
- Перевод от автора статьи - "тестирование от балды".
- Вид тестирования, который выполняется без подготовки к тестам, без определения ожидаемых результатов, проектирования тестовых сценариев.
- Неформальное, импровизационное тестирование.


## 10. Test Case (тестовый случай) <a target="_blank" rel="noreferrer" href="https://www.youtube.com/channel/UC-nnrcFlfveeW8iBRJe_XXQ" title="Youtube"><i class="fa fa-1x fa-youtube-square"></i></a>
Test Case — это артефакт/документ, описывающий совокупность шагов, 
конкретных условий и параметров, необходимых для проверки тестируемой функции.

Пример:
Action Expected Result Test Result
(passed/failed/blocked)
Open page «login» Login page is opened Passed

Каждый тест кейс должен иметь 3 части:
PreConditions Список действий, которые приводят систему к состоянию пригодному для проведения основной проверки. Либо список условий, выполнение которых говорит о том, что система находится в пригодном для проведения основного теста состояния.
Test Case Description Список действий, переводящих систему из одного состояния в другое, для получения результата, на основании которого можно сделать вывод о удовлетворении реализации, поставленным требованиям
PostConditions Список действий, переводящих систему в первоначальное состояние (состояние до проведения теста — initial state)
Виды Тестовых Сценариев:
Тест кейсы разделяются по ожидаемому результату на позитивные и негативные:
• Позитивный тест кейс использует только корректные данные и проверяет, что приложение правильно выполнило вызываемую функцию.
• Негативный тест кейс оперирует как корректными так и некорректными данными (минимум 1 некорректный параметр) и ставит целью проверку исключительных ситуаций (срабатывание валидаторов), а также проверяет, что вызываемая приложением функция не выполняется при срабатывании валидатора.



## 11. Check-list (Чек-лист) <a target="_blank" rel="noreferrer" href="https://www.youtube.com/channel/UC-nnrcFlfveeW8iBRJe_XXQ" title="Youtube"><i class="fa fa-1x fa-youtube-square"></i></a>

Check list — это документ, описывающий что должно быть протестировано. При этом чек-лист может быть абсолютно разного уровня детализации. На сколько детальным будет чек-лист зависит от требований к отчетности, уровня знания продукта сотрудниками и сложности продукта.
Как правило, чек-лист содержит только действия (шаги), без ожидаемого результата. Чек-лист менее формализован чем тестовый сценарий. Его уместно использовать тогда, когда тестовые сценарии будут избыточны. Также чек-лист ассоциируются с гибкими подходами в тестировании.

Дефект (он же баг) — это несоответствие фактического результата выполнения программы ожидаемому результату. Дефекты обнаруживаются на этапе тестирования программного обеспечения (ПО), когда тестировщик проводит сравнение полученных результатов работы программы (компонента или дизайна) с ожидаемым результатом, описанным в спецификации требований.

Error — ошибка пользователя, то есть он пытается использовать программу иным способом.
Пример — вводит буквы в поля, где требуется вводить цифры (возраст, количество товара и т.п.).
В качественной программе предусмотрены такие ситуации и выдаются сообщение об ошибке (error message), с красным крестиком которые.
Bug (defect) — ошибка программиста (или дизайнера или ещё кого, кто принимает участие в разработке), то есть когда в программе, что-то идёт не так как планировалось и программа выходит из-под контроля. Например, когда никак не контроллируется ввод пользователя, в результате неверные данные вызывают краши или иные «радости» в работе программы. Либо внутри программа построена так, что изначально не соответствует тому, что от неё ожидается.
Failure — сбой (причём не обязательно аппаратный) в работе компонента, всей программы или системы. То есть, существуют такие дефекты, которые приводят к сбоям (A defect caused the failure) и существуют такие, которые не приводят. UI-дефекты например. Но аппаратный сбой, никак не связанный с software, тоже является failure.

Баг Репорт (Bug Report) — это документ, описывающий ситуацию или последовательность действий приведшую к некорректной работе объекта тестирования, с указанием причин и ожидаемого результата.
Шапка
Короткое описание (Summary) Короткое описание проблемы, явно указывающее на причину и тип ошибочной ситуации.
Проект (Project) Название тестируемого проекта
Компонент приложения (Component) Название части или функции тестируемого продукта
Номер версии (Version) Версия на которой была найдена ошибка
Серьезность (Severity) Наиболее распространена пятиуровневая система градации серьезности дефекта:
• S1 Блокирующий (Blocker)
• S2 Критический (Critical)
• S3 Значительный (Major)
• S4 Незначительный (Minor)
• S5 Тривиальный (Trivial)
Приоритет (Priority) Приоритет дефекта:
• P1 Высокий (High)
• P2 Средний (Medium)
• P3 Низкий (Low)
Статус (Status) Статус бага. Зависит от используемой процедуры и жизненного цикла бага (bug workflow and life cycle)

Автор (Author) Создатель баг репорта
Назначен на (Assigned To) Имя сотрудника, назначенного на решение проблемы
Окружение
ОС / Сервис Пак и т.д. / Браузера + версия / ... Информация об окружении, на котором был найден баг: операционная система, сервис пак, для WEB тестирования — имя и версия браузера и т.д.
...
Описание
Шаги воспроизведения (Steps to Reproduce) Шаги, по которым можно легко воспроизвести ситуацию, приведшую к ошибке.
Фактический Результат (Result) Результат, полученный после прохождения шагов к воспроизведению
Ожидаемый результат (Expected Result) Ожидаемый правильный результат
Дополнения
Прикрепленный файл (Attachment) Файл с логами, скриншот или любой другой документ, который может помочь прояснить причину ошибки или указать на способ решения проблемы

Severity vs Priority
Серьезность (Severity) — это атрибут, характеризующий влияние дефекта на работоспособность приложения.
Приоритет (Priority) — это атрибут, указывающий на очередность выполнения задачи или устранения дефекта. Можно сказать, что это инструмент менеджера по планированию работ. Чем выше приоритет, тем быстрее нужно исправить дефект.
Severity выставляется тестировщиком
Priority — менеджером, тимлидом или заказчиком

Градация Серьезности дефекта (Severity)

S1 Блокирующая (Blocker)
Блокирующая ошибка, приводящая приложение в нерабочее состояние, в результате которого дальнейшая работа с тестируемой системой или ее ключевыми функциями становится невозможна. Решение проблемы необходимо для дальнейшего функционирования системы.

S2 Критическая (Critical)
Критическая ошибка, неправильно работающая ключевая бизнес логика, дыра в системе безопасности, проблема, приведшая к временному падению сервера или приводящая в нерабочее состояние некоторую часть системы, без возможности решения проблемы, используя другие входные точки. Решение проблемы необходимо для дальнейшей работы с ключевыми функциями тестируемой системой.

S3 Значительная (Major)
Значительная ошибка, часть основной бизнес логики работает некорректно. Ошибка не критична или есть возможность для работы с тестируемой функцией, используя другие входные точки.

S4 Незначительная (Minor)
Незначительная ошибка, не нарушающая бизнес логику тестируемой части приложения, очевидная проблема пользовательского интерфейса.

S5 Тривиальная (Trivial)
Тривиальная ошибка, не касающаяся бизнес логики приложения, плохо воспроизводимая проблема, малозаметная посредствам пользовательского интерфейса, проблема сторонних библиотек или сервисов, проблема, не оказывающая никакого влияния на общее качество продукта.

Градация Приоритета дефекта (Priority)
P1 Высокий (High)
Ошибка должна быть исправлена как можно быстрее, т.к. ее наличие является критической для проекта.
P2 Средний (Medium)
Ошибка должна быть исправлена, ее наличие не является критичной, но требует обязательного решения.
P3 Низкий (Low)
Ошибка должна быть исправлена, ее наличие не является критичной, и не требует срочного решения.



Traceability matrix — Матрица соответствия требований — это двумерная таблица, содержащая соответсвие функциональных требований (functional requirements) продукта и подготовленных тестовых сценариев (test cases). В заголовках колонок таблицы расположены требования, а в заголовках строк — тестовые сценарии. На пересечении — отметка, означающая, что требование текущей колонки покрыто тестовым сценарием текущей строки.
Матрица соответсвия требований используется QA-инженерами для валидации покрытия продукта тестами. МСТ является неотъемлемой частью тест-плана.



<div class="cell g-right-shadowed mobtab-maincol">
    <article class="b-typo b-typo_post" lang="ru">
        <h3>Источник: https://dou.ua/forums/topic/13389/ </h3>



        

        

        

        

        

        <p><strong>Тестирование программного обеспечения</strong>&nbsp;— проверка соответствия между реальным и&nbsp;ожидаемым поведением программы.<br></p>
        <p><strong>Тестирование</strong> &nbsp;— это одна из&nbsp;техник контроля качества, включающая в&nbsp;себя активности по&nbsp;планированию работ (Test Management), проектированию тестов (Test Design), выполнению тестирования (Test Execution) и&nbsp;анализу полученных результатов (Test Analysis).<br></p>

        <p><strong>Качество программного обеспечения (Software Quality)</strong>&nbsp;— это совокупность характеристик программного обеспечения, относящихся к&nbsp;его способности удовлетворять установленные и&nbsp;предполагаемые потребности. [Quality management and quality assurance]<br></p>

        <p><strong>Верификация (verification)</strong>&nbsp;— это процесс оценки системы или её&nbsp;компонентов с&nbsp;целью определения удовлетворяют&nbsp;ли результаты текущего этапа разработки условиям, сформированным в&nbsp;начале этого этапа[IEEE]. Т.е. выполняются&nbsp;ли наши цели, сроки, задачи по&nbsp;разработке проекта, определенные в&nbsp;начале текущей фазы.<br><strong>Валидация (validation)</strong>&nbsp;— это определение соответствия разрабатываемого&nbsp;ПО ожиданиям и&nbsp;потребностям пользователя, требованиям к&nbsp;системе [BS7925-1].<br>Также можно встретить иную интерпритацию:<br>Процесс оценки соответствия продукта явным требованиям (спецификациям) и&nbsp;есть верификация (verification), в&nbsp;то&nbsp;же время оценка соответствия продукта ожиданиям и&nbsp;требованиям пользователей&nbsp;— есть валидация (validation). Также часто можно встретить следующее определение этих понятий: <br>Validation&nbsp;— ’is this the right specification?’. <br>Verification&nbsp;— ’is the system correct to&nbsp;specification?’.<br></p>

        <p><strong>Цели тестирования</strong><br>Повысить вероятность того, что приложение, предназначенное для тестирования, будет работать правильно при любых обстоятельствах.<br>Повысить вероятность того, что приложение, предназначенное для тестирования, будет соответствовать всем описанным требованиям.<br>Предоставление актуальной информации о&nbsp;состоянии продукта на&nbsp;данный момент.<br></p>

        <p><strong>Этапы тестирования:</strong><br>1. Анализ продукта<br>2. Работа с&nbsp;требованиями<br>3. Разработка стратегии тестирования<br>и&nbsp;планирование процедур контроля качества<br>4. Создание тестовой документации<br>5. Тестирование прототипа<br>6. Основное тестирование<br>7. Стабилизация<br>8. Эксплуатация<br></p>

        <p><strong>Тест план (Test Plan)</strong>&nbsp;— это документ, описывающий весь объем работ по&nbsp;тестированию, начиная с&nbsp;описания объекта, стратегии, расписания, критериев начала и&nbsp;окончания тестирования, до&nbsp;необходимого в&nbsp;процессе работы оборудования, специальных знаний, а&nbsp;также оценки рисков с&nbsp;вариантами их&nbsp;разрешения.<br>Отвечает на&nbsp;вопросы:<br>Что надо тестировать?<br>Что будете тестировать?<br>Как будете тестировать?<br>Когда будете тестировать?<br>Критерии начала тестирования.<br>Критерии окончания тестирования.<br></p>

        <p><strong>Основные пункты тест плана</strong><br>В&nbsp;стандарте IEEE 829 перечислены пункты, из&nbsp;которых должен (пусть&nbsp;— может) состоять тест-план: <br>a) Test plan identifier; <br>b) Introduction; <br>c) Test items; <br>d) Features to&nbsp;be&nbsp;tested; <br>e) Features not to&nbsp;be&nbsp;tested; <br>f) Approach; <br>g) Item pass/fail criteria; <br>h) Suspension criteria and resumption requirements; <br>i) Test deliverables; <br>j) Testing tasks; <br>k) Environmental needs; <br>l) Responsibilities; <br>m) Staffing and training needs; <br>n) Schedule; <br>o) Risks and contingencies; <br>p) Approvals. <br></p>

        <p><strong>Тест дизайн</strong>&nbsp;— это этап процесса тестирования&nbsp;ПО, на&nbsp;котором проектируются и&nbsp;создаются тестовые сценарии (тест кейсы), в&nbsp;соответствии с&nbsp;определёнными ранее критериями качества и&nbsp;целями тестирования.<br>Роли, ответственные за&nbsp;тест дизайн:<br>•	Тест аналитик&nbsp;— определяет «ЧТО тестировать?»<br>•	Тест дизайнер&nbsp;— определяет «КАК тестировать?»<br></p>

        <p><strong>Техники тест дизайна</strong></p>

        <p><strong>•	Эквивалентное Разделение (Equivalence Partitioning&nbsp;— EP)</strong>. Как пример, у&nbsp;вас есть диапазон допустимых значений от&nbsp;1&nbsp;до&nbsp;10, вы&nbsp;должны выбрать одно верное значение внутри интервала, скажем, 5, и&nbsp;одно неверное значение вне интервала&nbsp;— 0. </p>

        <p><strong>•	Анализ Граничных Значений (Boundary Value Analysis&nbsp;— BVA).</strong> Если взять пример выше, в&nbsp;качестве значений для позитивного тестирования выберем минимальную и&nbsp;максимальную границы (1&nbsp;и&nbsp;10), и&nbsp;значения больше и&nbsp;меньше границ (0&nbsp;и&nbsp;11). Анализ Граничный значений может быть применен к&nbsp;полям, записям, файлам, или к&nbsp;любого рода сущностям имеющим ограничения. </p>

        <p><strong>•	Причина&nbsp;/ Следствие (Cause/Effect&nbsp;— CE).</strong> Это, как правило, ввод комбинаций условий (причин), для получения ответа от&nbsp;системы (Следствие). Например, вы&nbsp;проверяете возможность добавлять клиента, используя определенную экранную форму. Для этого вам необходимо будет ввести несколько полей, таких как «Имя», «Адрес», «Номер Телефона» а&nbsp;затем, нажать кнопку «Добавить»&nbsp;— это «Причина». После нажатия кнопки «Добавить», система добавляет клиента в&nbsp;базу данных и&nbsp;показывает его номер на&nbsp;экране&nbsp;— это «Следствие». </p>

        <p><strong>•	Предугадывание ошибки (Error Guessing&nbsp;— EG).</strong> Это когда тестировщик использует свои знания системы и&nbsp;способность к&nbsp;интерпретации спецификации на&nbsp;предмет того, чтобы «предугадать» при каких входных условиях система может выдать ошибку. Например, спецификация говорит: «пользователь должен ввести код». Тестировщик будет думать: «Что, если я&nbsp;не&nbsp;введу код?», «Что, если я&nbsp;введу неправильный код? », и&nbsp;так далее. Это и&nbsp;есть предугадывание ошибки. </p>

        <p><strong>•	Исчерпывающее тестирование (Exhaustive Testing&nbsp;— ET)</strong>&nbsp;— это крайний случай. В&nbsp;пределах этой техники вы&nbsp;должны проверить все возможные комбинации входных значений, и&nbsp;в&nbsp;принципе, это должно найти все проблемы. На&nbsp;практике применение этого метода не&nbsp;представляется возможным, из-за огромного количества входных значений.</p>

        <p><strong>•	Попарное тестирование (Pairwise Testing)</strong>&nbsp;— это техника формирования наборов тестовых данных. Сформулировать суть можно, например, вот так: формирование таких наборов данных, в&nbsp;которых каждое тестируемое значение каждого из&nbsp;проверяемых параметров хотя&nbsp;бы единожды сочетается с&nbsp;каждым тестируемым значением всех остальных проверяемых параметров.</p>

        <p>Допустим, какое-то значений (налог) для человека рассчитывается на&nbsp;основании его пола, возраста и&nbsp;наличия детей&nbsp;— получаем три входных параметра, для каждого из&nbsp;которых для тестов выбираем каким-то образом значения. Например: пол&nbsp;— мужской или женский; возраст&nbsp;— до&nbsp;25, от&nbsp;25&nbsp;до&nbsp;60, более&nbsp;60; наличие детей&nbsp;— да&nbsp;или нет. Для проверки правильности расчётов можно, конечно, перебрать все комбинации значений всех параметров:</p>

        <table border="1" cellpadding="4"><tbody><tr> <th>№</th> <th>пол</th> <th>возраст</th> <th>дети</th> </tr><tr> <td><b> 1</b></td> <td>мужчина</td> <td>до&nbsp;25</td> <td>детей нет</td> </tr><tr> <td><b> 2</b></td> <td>женщина</td> <td>до&nbsp;25</td> <td>детей нет</td> </tr><tr> <td><b> 3</b></td> <td>мужчина</td> <td><nobr>25-60</nobr></td> <td>детей нет</td> </tr><tr> <td><b> 4</b></td> <td>женщина</td> <td><nobr>25-60</nobr></td> <td>детей нет</td> </tr><tr> <td><b> 5</b></td> <td>мужчина</td> <td>старше 60</td> <td>детей нет</td> </tr><tr> <td><b> 6</b></td> <td>женщина</td> <td>старше 60</td> <td>детей нет</td> </tr><tr> <td><b> 7</b></td> <td>мужчина</td> <td>до&nbsp;25</td> <td>дети есть</td> </tr><tr> <td><b> 8</b></td> <td>женщина</td> <td>до&nbsp;25</td> <td>дети есть</td> </tr><tr> <td><b> 9</b></td> <td>мужчина</td> <td><nobr>25-60</nobr></td> <td>дети есть</td> </tr><tr> <td><b>10</b></td> <td>женщина</td> <td><nobr>25-60</nobr></td> <td>дети есть</td> </tr><tr> <td><b>11</b></td> <td>мужчина</td> <td>старше 60</td> <td>дети есть</td> </tr><tr> <td><b>12</b></td> <td>женщина</td> <td>старше 60</td> <td>дети есть</td> </tr></tbody></table>

        <p>А&nbsp;можно решить, что нам не&nbsp;нужны сочетания значений всех параметров со&nbsp;всеми, а&nbsp;мы&nbsp;хотим только убедиться, что мы&nbsp;проверим все уникальные пары значений параметров. Т.е., например, с&nbsp;точки зрения параметров пола и&nbsp;возраста мы&nbsp;хотим убедиться, что мы&nbsp;точно проверим мужчину до&nbsp;25, мужчину между 25&nbsp;и&nbsp;60, мужчину после&nbsp;60, а&nbsp;также женщину до&nbsp;25, женщину между 25&nbsp;и&nbsp;60, ну&nbsp;и&nbsp;женщину после 60. И&nbsp;точно так&nbsp;же для всех остальных пар параметров. И&nbsp;таким образом, мы&nbsp;можем получить гораздо меньше наборов значений (в&nbsp;них есть все пары значений, правда некоторые дважды):</p>

        <table border="1" cellpadding="4"><tbody><tr> <th>№</th> <th>пол</th> <th>возраст</th> <th>дети</th> </tr><tr> <td><b> 1</b></td> <td>мужчина</td> <td>до&nbsp;25</td> <td>детей нет</td> </tr><tr> <td><b> 2</b></td> <td>женщина</td> <td>до&nbsp;25</td> <td>дети есть</td> </tr><tr> <td><b> 3</b></td> <td>мужчина</td> <td><nobr>25-60</nobr></td> <td>дети есть</td> </tr><tr> <td><b> 4</b></td> <td>женщина</td> <td><nobr>25-60</nobr></td> <td>детей нет</td> </tr><tr> <td><b> 5</b></td> <td>мужчина</td> <td>старше 60</td> <td>детей нет</td> </tr><tr> <td><b> 6</b></td> <td>женщина</td> <td>старше 60</td> <td>дети есть</td> </tr></tbody></table>

        <p>Такой подход примерно и&nbsp;составляет суть техники pairwise testing&nbsp;— мы&nbsp;не&nbsp;проверяем все сочетания всех значений, но&nbsp;проверяем все пары значений.<br></p>

        <p><strong>Traceability matrix&nbsp;— Матрица соответствия требований</strong>&nbsp;— это двумерная таблица, содержащая соответсвие функциональных требований (functional requirements) продукта и&nbsp;подготовленных тестовых сценариев (test cases). В&nbsp;заголовках колонок таблицы расположены требования, а&nbsp;в&nbsp;заголовках строк&nbsp;— тестовые сценарии. На&nbsp;пересечении&nbsp;— отметка, означающая, что требование текущей колонки покрыто тестовым сценарием текущей строки.<br>Матрица соответсвия требований используется QA-инженерами для валидации покрытия продукта тестами. МСТ является неотъемлемой частью тест-плана.<br></p>

        <p><strong>Тестовый сценарий (Test Case)</strong>&nbsp;— это артефакт, описывающий совокупность шагов, конкретных условий и&nbsp;параметров, необходимых для проверки реализации тестируемой функции или её&nbsp;части.<br>Пример:<br>Action	 Expected Result	 Test Result<br>(passed/failed/blocked)<br>Open page «login»	Login page is&nbsp;opened	Passed</p>

        <p>Каждый тест кейс должен иметь 3&nbsp;части:<br>PreConditions	Список действий, которые приводят систему к&nbsp;состоянию пригодному для проведения основной проверки. Либо список условий, выполнение которых говорит о&nbsp;том, что система находится в&nbsp;пригодном для проведения основного теста состояния.<br>Test Case Description	Список действий, переводящих систему из&nbsp;одного состояния в&nbsp;другое, для получения результата, на&nbsp;основании которого можно сделать вывод о&nbsp;удовлетворении реализации, поставленным требованиям<br>PostConditions	Список действий, переводящих систему в&nbsp;первоначальное состояние (состояние до&nbsp;проведения теста&nbsp;— initial state)<br>Виды Тестовых Сценариев:<br>Тест кейсы разделяются по&nbsp;ожидаемому результату на&nbsp;позитивные и&nbsp;негативные:<br>•	Позитивный тест кейс использует только корректные данные и&nbsp;проверяет, что приложение правильно выполнило вызываемую функцию.<br>•	Негативный тест кейс оперирует как корректными так и&nbsp;некорректными данными (минимум 1&nbsp;некорректный параметр) и&nbsp;ставит целью проверку исключительных ситуаций (срабатывание валидаторов), а&nbsp;также проверяет, что вызываемая приложением функция не&nbsp;выполняется при срабатывании валидатора.<br></p>

        <p><strong>Чек-лист (check list)</strong>&nbsp;— это документ, описывающий что должно быть протестировано. При этом чек-лист может быть абсолютно разного уровня детализации. На&nbsp;сколько детальным будет чек-лист зависит от&nbsp;требований к&nbsp;отчетности, уровня знания продукта сотрудниками и&nbsp;сложности продукта.<br>Как правило, чек-лист содержит только действия (шаги), без ожидаемого результата. Чек-лист менее формализован чем тестовый сценарий. Его уместно использовать тогда, когда тестовые сценарии будут избыточны. Также чек-лист ассоциируются с&nbsp;гибкими подходами в&nbsp;тестировании.<br></p>

        <p><strong>Дефект (он&nbsp;же баг)</strong>&nbsp;— это несоответствие фактического результата выполнения программы ожидаемому результату. Дефекты обнаруживаются на&nbsp;этапе тестирования программного обеспечения (ПО), когда тестировщик проводит сравнение полученных результатов работы программы (компонента или дизайна) с&nbsp;ожидаемым результатом, описанным в&nbsp;спецификации требований.<br></p>

        <p><strong>Error</strong>&nbsp;— ошибка пользователя, то&nbsp;есть он&nbsp;пытается использовать программу иным способом.<br>Пример&nbsp;— вводит буквы в&nbsp;поля, где требуется вводить цифры (возраст, количество товара и&nbsp;т.п.).<br>В&nbsp;качественной программе предусмотрены такие ситуации и&nbsp;выдаются сообщение об&nbsp;ошибке (error message), с&nbsp;красным крестиком которые.<br><strong>Bug (defect)</strong>&nbsp;— ошибка программиста (или дизайнера или ещё кого, кто принимает участие в&nbsp;разработке), то&nbsp;есть когда в&nbsp;программе, что-то идёт не&nbsp;так как планировалось и&nbsp;программа выходит из-под контроля. Например, когда никак не&nbsp;контроллируется ввод пользователя, в&nbsp;результате неверные данные вызывают краши или иные «радости» в&nbsp;работе программы. Либо внутри программа построена так, что изначально не&nbsp;соответствует тому, что от&nbsp;неё ожидается. <br><strong>Failure</strong>&nbsp;— сбой (причём не&nbsp;обязательно аппаратный) в&nbsp;работе компонента, всей программы или системы. То&nbsp;есть, существуют такие дефекты, которые приводят к&nbsp;сбоям (A&nbsp;defect caused the failure) и&nbsp;существуют такие, которые не&nbsp;приводят. UI-дефекты например. Но&nbsp;аппаратный сбой, никак не&nbsp;связанный с&nbsp;software, тоже является failure.<br></p>

        <p><strong>Баг Репорт (Bug Report)</strong>&nbsp;— это документ, описывающий ситуацию или последовательность действий приведшую к&nbsp;некорректной работе объекта тестирования, с&nbsp;указанием причин и&nbsp;ожидаемого результата.<br>Шапка<br>Короткое описание (Summary)	Короткое описание проблемы, явно указывающее на&nbsp;причину и&nbsp;тип ошибочной ситуации.<br>Проект (Project)	Название тестируемого проекта<br>Компонент приложения (Component)	Название части или функции тестируемого продукта<br>Номер версии (Version)	Версия на&nbsp;которой была найдена ошибка<br>Серьезность (Severity)	Наиболее распространена пятиуровневая система градации серьезности дефекта:<br>•	S1&nbsp;Блокирующий (Blocker)<br>•	S2&nbsp;Критический (Critical)<br>•	S3&nbsp;Значительный (Major)<br>•	S4&nbsp;Незначительный (Minor)<br>•	S5&nbsp;Тривиальный (Trivial)<br>Приоритет (Priority)	Приоритет дефекта:<br>•	P1&nbsp;Высокий (High)<br>•	P2&nbsp;Средний (Medium)<br>•	P3&nbsp;Низкий (Low)<br>Статус (Status)	Статус бага. Зависит от&nbsp;используемой процедуры и&nbsp;жизненного цикла бага (bug workflow and life cycle)</p>

        <p>Автор (Author)	Создатель баг репорта<br>Назначен&nbsp;на (Assigned To)	Имя сотрудника, назначенного на&nbsp;решение проблемы<br>Окружение<br>ОС&nbsp;/ Сервис Пак и&nbsp;т.д.&nbsp;/ Браузера + версия&nbsp;/ ...	Информация об&nbsp;окружении, на&nbsp;котором был найден баг: операционная система, сервис пак, для WEB тестирования&nbsp;— имя и&nbsp;версия браузера и&nbsp;т.д.<br>...	 <br>Описание<br>Шаги воспроизведения (Steps to&nbsp;Reproduce)	Шаги, по&nbsp;которым можно легко воспроизвести ситуацию, приведшую к&nbsp;ошибке.<br>Фактический Результат (Result)	Результат, полученный после прохождения шагов к&nbsp;воспроизведению<br>Ожидаемый результат (Expected Result)	Ожидаемый правильный результат<br>Дополнения<br>Прикрепленный файл (Attachment)	Файл с&nbsp;логами, скриншот или любой другой документ, который может помочь прояснить причину ошибки или указать на&nbsp;способ решения проблемы<br></p>

        <p><strong>Severity vs&nbsp;Priority</strong><br>Серьезность (Severity)&nbsp;— это атрибут, характеризующий влияние дефекта на&nbsp;работоспособность приложения.<br>Приоритет (Priority)&nbsp;— это атрибут, указывающий на&nbsp;очередность выполнения задачи или устранения дефекта. Можно сказать, что это инструмент менеджера по&nbsp;планированию работ. Чем выше приоритет, тем быстрее нужно исправить дефект.<br>Severity выставляется тестировщиком<br>Priority&nbsp;— менеджером, тимлидом или заказчиком</p>

        <p>Градация Серьезности дефекта (Severity)</p>

        <p><strong>S1&nbsp;Блокирующая (Blocker)</strong><br>Блокирующая ошибка, приводящая приложение в&nbsp;нерабочее состояние, в&nbsp;результате которого дальнейшая работа с&nbsp;тестируемой системой или ее&nbsp;ключевыми функциями становится невозможна. Решение проблемы необходимо для дальнейшего функционирования системы.</p>

        <p><strong>S2&nbsp;Критическая (Critical)</strong><br>Критическая ошибка, неправильно работающая ключевая бизнес логика, дыра в&nbsp;системе безопасности, проблема, приведшая к&nbsp;временному падению сервера или приводящая в&nbsp;нерабочее состояние некоторую часть системы, без возможности решения проблемы, используя другие входные точки. Решение проблемы необходимо для дальнейшей работы с&nbsp;ключевыми функциями тестируемой системой.</p>

        <p><strong>S3&nbsp;Значительная (Major) </strong><br>Значительная ошибка, часть основной бизнес логики работает некорректно. Ошибка не&nbsp;критична или есть возможность для работы с&nbsp;тестируемой функцией, используя другие входные точки.</p>

        <p><strong>S4&nbsp;Незначительная (Minor) </strong><br>Незначительная ошибка, не&nbsp;нарушающая бизнес логику тестируемой части приложения, очевидная проблема пользовательского интерфейса.</p>

        <p><strong>S5&nbsp;Тривиальная (Trivial) </strong><br>Тривиальная ошибка, не&nbsp;касающаяся бизнес логики приложения, плохо воспроизводимая проблема, малозаметная посредствам пользовательского интерфейса, проблема сторонних библиотек или сервисов, проблема, не&nbsp;оказывающая никакого влияния на&nbsp;общее качество продукта.<br></p>

        <p>Градация Приоритета дефекта (Priority)<br><strong>P1&nbsp;Высокий (High) </strong><br>Ошибка должна быть исправлена как можно быстрее, т.к.&nbsp;ее&nbsp;наличие является критической для проекта.<br><strong>P2&nbsp;Средний (Medium) </strong><br>Ошибка должна быть исправлена, ее&nbsp;наличие не&nbsp;является критичной, но&nbsp;требует обязательного решения.<br><strong>P3&nbsp;Низкий (Low) </strong><br>Ошибка должна быть исправлена, ее&nbsp;наличие не&nbsp;является критичной, и&nbsp;не&nbsp;требует срочного решения.<br></p>

        <h2>Уровни Тестирования</h2>

        <p><strong>1.	 Модульное тестирование (Unit Testing)</strong><br>Компонентное (модульное) тестирование проверяет функциональность и&nbsp;ищет дефекты в&nbsp;частях приложения, которые доступны и&nbsp;могут быть протестированы по-отдельности (модули программ, объекты, классы, функции и&nbsp;т.д.).</p>

        <p><strong>2.	Интеграционное тестирование (Integration Testing)</strong><br>Проверяется взаимодействие между компонентами системы после проведения компонентного тестирования.</p>

        <p><strong>3.	Системное тестирование (System Testing)</strong><br>Основной задачей системного тестирования является проверка как функциональных, так и&nbsp;не&nbsp;функциональных требований в&nbsp;системе в&nbsp;целом. При этом выявляются дефекты, такие как неверное использование ресурсов системы, непредусмотренные комбинации данных пользовательского уровня, несовместимость с&nbsp;окружением, непредусмотренные сценарии использования, отсутствующая или неверная функциональность, неудобство использования и&nbsp;т.д.</p>

        <p><strong>4.	Операционное тестирование (Release Testing).</strong><br>Даже если система удовлетворяет всем требованиям, важно убедиться в&nbsp;том, что она удовлетворяет нуждам пользователя и&nbsp;выполняет свою роль в&nbsp;среде своей эксплуатации, как это было определено в&nbsp;бизнес моделе системы. Следует учесть, что и&nbsp;бизнес модель может содержать ошибки. Поэтому так важно провести операционное тестирование как финальный шаг валидации. Кроме этого, тестирование в&nbsp;среде эксплуатации позволяет выявить и&nbsp;нефункциональные проблемы, такие как: конфликт с&nbsp;другими системами, смежными в&nbsp;области бизнеса или в&nbsp;программных и&nbsp;электронных окружениях; недостаточная производительность системы в&nbsp;среде эксплуатации и&nbsp;др. Очевидно, что нахождение подобных вещей на&nbsp;стадии внедрения&nbsp;— критичная и&nbsp;дорогостоящая проблема. Поэтому так важно проведение не&nbsp;только верификации, но&nbsp;и&nbsp;валидации, с&nbsp;самых ранних этапов разработки ПО.</p>

        <p><strong>5.	Приемочное тестирование (Acceptance Testing)</strong><br>Формальный процесс тестирования, который проверяет соответствие системы требованиям и&nbsp;проводится с&nbsp;целью:<br>•	определения удовлетворяет&nbsp;ли система приемочным критериям;<br>•	вынесения решения заказчиком или другим уполномоченным лицом принимается приложение или нет.<br></p>

        <h2>Виды&nbsp;/ типы тестирования</h2>

        <h4>Функциональные виды тестирования</h4>

        <p>•	Функциональное тестирование (Functional testing)<br>•	Тестирование пользовательского интерфейса (GUI&nbsp;Testing)<br>•	Тестирование безопасности (Security and Access Control Testing)<br>•	Тестирование взаимодействия (Interoperability Testing)</p>

        <h4>Нефункциональные виды тестирования</h4>

        <p>•	Все виды тестирования производительности:<br>o	нагрузочное тестирование (Performance and Load Testing)<br>o	стрессовое тестирование (Stress Testing)<br>o	тестирование стабильности или надежности (Stability&nbsp;/ Reliability Testing)<br>o	объемное тестирование (Volume Testing)<br>•	Тестирование установки (Installation testing)<br>•	Тестирование удобства пользования (Usability Testing)<br>•	Тестирование на&nbsp;отказ и&nbsp;восстановление (Failover and Recovery Testing)<br>•	Конфигурационное тестирование (Configuration Testing)</p>

        <h4>Связанные с&nbsp;изменениями виды тестирования</h4>•	Дымовое тестирование (Smoke Testing)<br>•	Регрессионное тестирование (Regression Testing)<br>•	Повторное тестирование (Re-testing)<br>•	Тестирование сборки (Build Verification Test)<br>•	Санитарное тестирование или проверка согласованности/исправности (Sanity Testing)

        <p><strong>Функциональное тестирование</strong> рассматривает заранее указанное поведение и&nbsp;основывается на&nbsp;анализе спецификаций функциональности компонента или системы в&nbsp;целом.</p>

        <p><strong>Тестирование пользовательского интерфейса (GUI&nbsp;Testing)</strong>&nbsp;— функциональная проверка интерфейса на&nbsp;соответствие требованиям&nbsp;— размер, шрифт, цвет, consistent behavior.</p>

        <p><strong>Тестирование безопасности&nbsp;</strong>— это стратегия тестирования, используемая для проверки безопасности системы, а&nbsp;также для анализа рисков, связанных с&nbsp;обеспечением целостного подхода к&nbsp;защите приложения, атак хакеров, вирусов, несанкционированного доступа к&nbsp;конфиденциальным данным.</p>

        <p><strong>Тестирование взаимодействия (Interoperability Testing)&nbsp;</strong>— это функциональное тестирование, проверяющее способность приложения взаимодействовать с&nbsp;одним и&nbsp;более компонентами или системами и&nbsp;включающее в&nbsp;себя тестирование совместимости (compatibility testing) и&nbsp;интеграционное тестирование</p>

        <p><strong>Нагрузочное тестирование</strong>&nbsp;— это автоматизированное тестирование, имитирующее работу определенного количества бизнес пользователей на&nbsp;каком-либо общем (разделяемом ими) ресурсе.</p>

        <p><strong>Стрессовое тестирование (Stress Testing)</strong> позволяет проверить насколько приложение и&nbsp;система в&nbsp;целом работоспособны в&nbsp;условиях стресса и&nbsp;также оценить способность системы к&nbsp;регенерации, т.е.&nbsp;к&nbsp;возвращению к&nbsp;нормальному состоянию после прекращения воздействия стресса. Стрессом в&nbsp;данном контексте может быть повышение интенсивности выполнения операций до&nbsp;очень высоких значений или аварийное изменение конфигурации сервера. Также одной из&nbsp;задач при стрессовом тестировании может быть оценка деградации производительности, таким образом цели стрессового тестирования могут пересекаться с&nbsp;целями тестирования производительности.</p>

        <p><strong>Объемное тестирование (Volume Testing).</strong> Задачей объемного тестирования является получение оценки производительности при увеличении объемов данных в&nbsp;базе данных приложения</p>

        <p><strong>Тестирование стабильности или надежности (Stability&nbsp;/ Reliability Testing).</strong> Задачей тестирования стабильности (надежности) является проверка работоспособности приложения при длительном (многочасовом) тестировании со&nbsp;средним уровнем нагрузки.</p>

        <p><strong>Тестирование установки</strong> направленно на&nbsp;проверку успешной инсталляции и&nbsp;настройки, а&nbsp;также обновления или удаления программного обеспечения.</p>

        <p><strong>Тестирование удобства пользования</strong>&nbsp;— это метод тестирования, направленный на&nbsp;установление степени удобства использования, обучаемости, понятности и&nbsp;привлекательности для пользователей разрабатываемого продукта в&nbsp;контексте заданных условий. Сюда также входит:<br>User eXperience (UX)&nbsp;— ощущение, испытываемое пользователем во&nbsp;время использования цифрового продукта, в&nbsp;то&nbsp;время как User interface&nbsp;— это инструмент, позволяющий осуществлять интеракцию «пользователь&nbsp;— веб-ресурс».</p>

        <p><strong>Тестирование на&nbsp;отказ и&nbsp;восстановление (Failover and Recovery Testing) </strong>проверяет тестируемый продукт с&nbsp;точки зрения способности противостоять и&nbsp;успешно восстанавливаться после возможных сбоев, возникших в&nbsp;связи с&nbsp;ошибками программного обеспечения, отказами оборудования или проблемами связи (например, отказ сети). Целью данного вида тестирования является проверка систем восстановления (или дублирующих основной функционал систем), которые, в&nbsp;случае возникновения сбоев, обеспечат сохранность и&nbsp;целостность данных тестируемого продукта. </p>

        <p><strong>Конфигурационное тестирование (Configuration Testing)&nbsp;</strong>— специальный вид тестирования, направленный на&nbsp;проверку работы программного обеспечения при различных конфигурациях системы (заявленных платформах, поддерживаемых драйверах, при различных конфигурациях компьютеров и&nbsp;т.д.)</p>

        <p><strong>Дымовое (Smoke)</strong> тестирование рассматривается как короткий цикл тестов, выполняемый для подтверждения того, что после сборки кода (нового или исправленного) устанавливаемое приложение, стартует и&nbsp;выполняет основные функции.</p>

        <p><strong>Регрессионное тестирование&nbsp;</strong>— это вид тестирования направленный на&nbsp;проверку изменений, сделанных в&nbsp;приложении или окружающей среде (починка дефекта, слияние кода, миграция на&nbsp;другую операционную систему, базу данных, веб сервер или сервер приложения), для подтверждения того факта, что существующая ранее функциональность работает как и&nbsp;прежде. Регрессионными могут быть как функциональные, так и&nbsp;нефункциональные тесты.</p>

        <p><strong>Повторное тестирование</strong>&nbsp;— тестирование, во&nbsp;время которого исполняются тестовые сценарии, выявившие ошибки во&nbsp;время последнего запуска, для подтверждения успешности исправления этих ошибок.<br>В&nbsp;чем разница между regression testing и&nbsp;re-testing? <br>Re-testing&nbsp;— проверяется исправление багов<br>Regression testing&nbsp;— проверяется&nbsp;то, что исправление багов, а&nbsp;также любые изменения в&nbsp;коде приложения, не&nbsp;повлияли на&nbsp;другие модули&nbsp;ПО и&nbsp;не&nbsp;вызвало новых багов.</p>

        <p><strong>Тестирование сборки или Build Verification Test</strong>&nbsp;— тестирование направленное на&nbsp;определение соответствия, выпущенной версии, критериям качества для начала тестирования. По&nbsp;своим целям является аналогом Дымового Тестирования, направленного на&nbsp;приемку новой версии в&nbsp;дальнейшее тестирование или эксплуатацию. Вглубь оно может проникать дальше, в&nbsp;зависимости от&nbsp;требований к&nbsp;качеству выпущенной версии.</p>

        <p><strong>Санитарное тестирование&nbsp;</strong>— это узконаправленное тестирование достаточное для доказательства того, что конкретная функция работает согласно заявленным в&nbsp;спецификации требованиям. Является подмножеством регрессионного тестирования. Используется для определения работоспособности определенной части приложения после изменений произведенных в&nbsp;ней или окружающей среде. Обычно выполняется вручную.</p>

        <p><a href="http://habrastorage.org/files/bd6/dcb/bb7/bd6dcbbb7d7c44a485b65ae29b4c0ae4.png" target="_blank"> <img src="https://hsto.org/files/bd6/dcb/bb7/bd6dcbbb7d7c44a485b65ae29b4c0ae4.png"> </a><br></p>

        <p><strong>Подходы к&nbsp;интеграционному тестированию:</strong><br><strong>•	Снизу вверх (Bottom Up&nbsp;Integration)</strong><br>Все низкоуровневые модули, процедуры или функции собираются воедино и&nbsp;затем тестируются. После чего собирается следующий уровень модулей для проведения интеграционного тестирования. Данный подход считается полезным, если все или практически все модули, разрабатываемого уровня, готовы. Также данный подход помогает определить по&nbsp;результатам тестирования уровень готовности приложения.<br><strong>•	Сверху вниз (Top Down Integration)</strong><br>Вначале тестируются все высокоуровневые модули, и&nbsp;постепенно один за&nbsp;другим добавляются низкоуровневые. Все модули более низкого уровня симулируются заглушками с&nbsp;аналогичной функциональностью, затем по&nbsp;мере готовности они заменяются реальными активными компонентами. Таким образом мы&nbsp;проводим тестирование сверху вниз.<br><strong>•	Большой взрыв («Big Bang» Integration)</strong><br>Все или практически все разработанные модули собираются вместе в&nbsp;виде законченной системы или ее&nbsp;основной части, и&nbsp;затем проводится интеграционное тестирование. Такой подход очень хорош для сохранения времени. Однако если тест кейсы и&nbsp;их&nbsp;результаты записаны не&nbsp;верно, то&nbsp;сам процесс интеграции сильно осложнится, что станет преградой для команды тестирования при достижении основной цели интеграционного тестирования.</p>



        <h2>Принципы тестирования</h2>

        <p><strong>Принцип 1</strong>&nbsp;— Тестирование демонстрирует наличие дефектов (Testing shows presence of&nbsp;defects)<br>Тестирование может показать, что дефекты присутствуют, но&nbsp;не&nbsp;может доказать, что их&nbsp;нет. Тестирование снижает вероятность наличия дефектов, находящихся в&nbsp;программном обеспечении, но, даже если дефекты не&nbsp;были обнаружены, это не&nbsp;доказывает его корректности.</p>

        <p><strong>Принцип 2&nbsp;</strong>— Исчерпывающее тестирование недостижимо (Exhaustive testing is&nbsp;impossible)<br>Полное тестирование с&nbsp;использованием всех комбинаций вводов и&nbsp;предусловий физически невыполнимо, за&nbsp;исключением тривиальных случаев. Вместо исчерпывающего тестирования должны использоваться анализ рисков и&nbsp;расстановка приоритетов, чтобы более точно сфокусировать усилия по&nbsp;тестированию.</p>

        <p><strong>Принцип 3&nbsp;</strong>— Раннее тестирование (Early testing)<br>Чтобы найти дефекты как можно раньше, активности по&nbsp;тестированию должны быть начаты как можно раньше в&nbsp;жизненном цикле разработки программного обеспечения или системы, и&nbsp;должны быть сфокусированы на&nbsp;определенных целях.</p>

        <p><strong>Принцип 4</strong>&nbsp;— Скопление дефектов (Defects clustering)<br>Усилия тестирования должны быть сосредоточены пропорционально ожидаемой, а&nbsp;позже реальной плотности дефектов по&nbsp;модулям. Как правило, большая часть дефектов, обнаруженных при тестировании или повлекших за&nbsp;собой основное количество сбоев системы, содержится в&nbsp;небольшом количестве модулей.</p>

        <p><strong>Принцип 5</strong>&nbsp;— Парадокс пестицида (Pesticide paradox)<br>Если одни и&nbsp;те&nbsp;же тесты будут прогоняться много раз, в&nbsp;конечном счете этот набор тестовых сценариев больше не&nbsp;будет находить новых дефектов. Чтобы преодолеть этот «парадокс пестицида», тестовые сценарии должны регулярно рецензироваться и&nbsp;корректироваться, новые тесты должны быть разносторонними, чтобы охватить все компоненты программного обеспечения,<br>или системы, и&nbsp;найти как можно больше дефектов.</p>

        <p><strong>Принцип 6</strong>&nbsp;— Тестирование зависит от&nbsp;контекста (Testing is&nbsp;concept depending)<br>Тестирование выполняется по-разному в&nbsp;зависимости от&nbsp;контекста. Например, программное обеспечение, в&nbsp;котором критически важна безопасность, тестируется иначе, чем сайт электронной коммерции. <br><strong>Принцип 7</strong>&nbsp;— Заблуждение об&nbsp;отсутствии ошибок (Absence-of-errors fallacy)<br>Обнаружение и&nbsp;исправление дефектов не&nbsp;помогут, если созданная система не&nbsp;подходит пользователю и&nbsp;не&nbsp;удовлетворяет его ожиданиям и&nbsp;потребностям.<br></p>

        <p><strong>Cтатическое и&nbsp;динамическое тестирование</strong><br>Статическое тестирование отличается от&nbsp;динамического тем, что производится без запуска программного кода продукта. Тестирование осуществляется путем анализа программного кода (code review) или скомпилированного кода. Анализ может производиться как вручную, так и&nbsp;с&nbsp;помощью специальных инструментальных средств. Целью анализа является раннее выявление ошибок и&nbsp;потенциальных проблем в&nbsp;продукте. Также к&nbsp;статическому тестированию относится тестирования спецификации и&nbsp;прочей документации.<br></p>

        <p><strong>Исследовательское&nbsp;/ ad-hoc тестирование</strong><br>Простейшее определение исследовательского тестирования&nbsp;— это разработка и&nbsp;выполнения тестов в&nbsp;одно и&nbsp;то&nbsp;же время. Что является противоположностью сценарного подхода (с&nbsp;его предопределенными процедурами тестирования, неважно ручными или автоматизированными). Исследовательские тесты, в&nbsp;отличие от&nbsp;сценарных тестов, не&nbsp;определены заранее и&nbsp;не&nbsp;выполняются в&nbsp;точном соответствии с&nbsp;планом.</p>

        <p>Разница между ad&nbsp;hoc и&nbsp;exploratory testing в&nbsp;том, что теоретически, ad&nbsp;hoc может провести кто угодно, а&nbsp;для проведения exploratory необходимо мастерство и&nbsp;владение определенными техниками. Обратите внимание, что определенные техники это не&nbsp;только техники тестирования.<br></p>

        <p><strong>Требования</strong>&nbsp;— это спецификация (описание) того, что должно быть реализовано.<br>Требования описывают&nbsp;то, что необходимо реализовать, без детализации технической стороны решения. Что, а&nbsp;не&nbsp;как.</p>

        <p><strong>Требования к&nbsp;требованиям:</strong><br>• Корректность<br>• Недвусмысленность<br>• Полнота набора требований<br>• Непротиворечивость набора требований<br>• Проверяемость (тестопригодность)<br>• Трассируемость<br>• Понимаемость</p>

        <p><strong>Жизненный цикл бага</strong></p>

        <p><a href="http://www.zeelabs.com/images/bug_life_cycle_diagram.jpg" target="_blank"> <img src="https://s.dou.ua/storage-files/bug_life_cycle_diagram.jpg"> </a><br></p>

        <p><strong>Стадии разработки ПО</strong>&nbsp;— это этапы, которые проходят команды разработчиков&nbsp;ПО, прежде чем программа станет доступной для широко круга пользователей. Разработка ПО&nbsp;начинается с&nbsp;первоначального этапа разработки (стадия «пре-альфа») и&nbsp;продолжается стадиями, на&nbsp;которых продукт дорабатывается и&nbsp;модернизируется. Финальным этапом этого процесса становится выпуск на&nbsp;рынок окончательной версии программного обеспечения («общедоступного релиза»).</p>

        <p>Программный продукт проходит следующие стадии:<br>• анализ требований к&nbsp;проекту;<br>• проектирование;<br>• реализация;<br>• тестирование продукта;<br>• внедрение и&nbsp;поддержка.</p>

        <p>Каждой стадии разработки&nbsp;ПО присваивается определенный порядковый номер. Также каждый этап имеет свое собственное название, которое характеризует готовность продукта на&nbsp;этой стадии.<br></p>

        <p><strong>Жизненный цикл разработки ПО:</strong><br>• Пре-альфа<br>• Альфа<br>• Бета<br>• Релиз-кандидат<br>• Релиз<br>• Пост-релиз<br></p>

        <p><strong>Таблица принятия решений (decision table)</strong>&nbsp;— В&nbsp;таблицах решений представлен набор условий, одновременное выполнение которых должно привести к&nbsp;определенному действию/решению. <br><a href="http://www.interface.ru/iarticle/img/1170_3.bmp%09" target="_blank"> <img src="https://s.dou.ua/storage-files/1170_3.png"> </a><br></p>

        <p><strong>QA/QC/Test Engineer</strong><br><a href="http://qalight.com.ua/images/Screenshot_2.png" target="_blank"> <img src="https://s.dou.ua/storage-files/Screenshot_2.png"> </a><br>Тестирование&nbsp;— часть QC. QC&nbsp;— часть QA.<br></p>

        <p><br>Источники: <a href="https://dou.ua/forums/topic/13389/" target="_blank">dou.ua/forums/topic/13389</a>, <a href="http://www.protesting.ru/" target="_blank">www.protesting.ru</a>, <a href="http://bugscatcher.net/" target="_blank">bugscatcher.net</a>, <a href="http://qalight.com.ua/" target="_blank">qalight.com.ua</a>, <a href="https://thinkingintests.wordpress.com" target="_blank">thinkingintests.wordpress.com</a>, книга ISTQB, <a href="http://www.quizful.net/" target="_blank">www.quizful.net</a>, <a href="http://bugsclock.blogspot.com/" target="_blank">bugsclock.blogspot.com</a>, <a href="http://www.zeelabs.com/" target="_blank">www.zeelabs.com</a>, <a href="http://devopswiki.net/" target="_blank">devopswiki.net</a>, <a href="http://hvorostovoz.blogspot.com/" target="_blank">hvorostovoz.blogspot.com</a>.</p>



    </article>



























</div>
